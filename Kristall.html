<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Kristall-Resonanz</title>
  <style>
    :root{
      --bg0:#05060a;
      --bg1:#0a0f22;
      --txt:#e9ecff;
      --mut:#b8c0ffb3;
      --panel:#0b1020cc;
      --stroke:#a9b7ff33;
    }
    html,body{height:100%;margin:0}
    body{
      font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--txt);
      background:
        radial-gradient(900px 650px at 30% 20%, #151c3a 0%, var(--bg1) 55%, var(--bg0) 100%);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
    }
    .wrap{width:min(1100px,100%);display:grid;gap:14px;}
    header{display:flex;gap:12px;justify-content:space-between;align-items:flex-start;flex-wrap:wrap;}
    h1{margin:0;font-size:clamp(18px,2.8vw,26px);letter-spacing:.3px}
    .sub{margin:6px 0 0;color:var(--mut);max-width:86ch}
    .panel{
      background:linear-gradient(180deg,#101736cc,var(--panel));
      border:1px solid var(--stroke);
      border-radius:22px;
      padding:14px;
      box-shadow:0 18px 60px #00000070;
      backdrop-filter:blur(10px);
    }
    .topbar{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-bottom:10px;}
    .pill{
      display:inline-flex;align-items:center;gap:8px;
      padding:8px 12px;border-radius:999px;
      border:1px solid var(--stroke);
      background:#0a0d18aa;
      color:var(--mut);font-size:14px;
      user-select:none;
    }
    .pill input{accent-color:#cfe0ff}
    button{
      appearance:none;
      border:1px solid var(--stroke);
      background:linear-gradient(180deg,#0f1735,#090b16);
      color:var(--txt);
      border-radius:999px;
      padding:9px 12px;
      cursor:pointer;
    }
    button:hover{border-color:#cfe0ff55}
    .hud{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;margin-top:10px;}
    .status{color:var(--mut);font-size:14px;}
    .reveal{
      display:none;
      margin-top:12px;
      padding:12px 14px;
      border-radius:18px;
      border:1px solid #a6ffcb55;
      background:linear-gradient(180deg,#0b1a16,#070b0b);
      box-shadow:0 0 40px #a6ffcb14;
    }
    .reveal b{color:#d7ffe8}
    .small{font-size:12px;color:var(--mut)}
    canvas{
      width:100%;
      height:min(68vh,640px);
      border-radius:18px;
      border:1px dashed var(--stroke);
      background:radial-gradient(900px 520px at 40% 30%,#18204a88,transparent 70%);
      display:block;
      touch-action:manipulation;
    }
    .legend{
      margin-top:10px;
      padding:10px 12px;
      border-radius:16px;
      border:1px solid var(--stroke);
      background:#0a0d18aa;
      color:var(--mut);
      font-size:13px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Kristall-Resonanz</h1>
        <p class="sub">
          Leuchtende Punkte in verschiedenen Farben und Symbolen erscheinen auf der Steinplatte.
          Feine Linien aus Licht flackern auf, während der Fels unter deinen Fingern leicht zu vibrieren beginnt.
          Wärme sammelt sich in dem Stein – als würde er auf eine unsichtbare Melodie warten.
        </p>
      </div>
    </header>

    <div class="panel">
      <div class="topbar">
        <label class="pill"><input id="sound" type="checkbox" checked> Ton</label>
        <label class="pill"><input id="easy" type="checkbox"> Einfach (zeigt Länge)</label>
        <button id="reset" type="button">Zurücksetzen</button>
        <span class="pill" id="progressPill">
          Resonanz: <span id="prog">0</span><span id="progMax" style="display:none"> / <span id="max"></span></span>
        </span>
      </div>

      <canvas id="c"></canvas>

      <div class="legend">
        <b>Hinweis:</b> Die Zeichen wiederholen sich selten, und manche scheinen miteinander in Einklang zu stehen.
        Mit jeder Berührung verändern sich Wärme und Vibration der Platte – als würde der Stein deinen Tastsinn stimmen.
      </div>

      <div class="hud">
        <div class="status" id="status">
          Leuchtende Punkte in wechselnden Farben erscheinen auf der Steinplatte, feine Symbole glimmen im Fels.
          Ein kaum spürbares Vibrieren geht von dem Stein aus, während er langsam wärmer wird.
        </div>
        <div class="small">DM-Tipp: Im Script <b>LETTER_ORDER</b> und <b>letterIndices</b> anpassen.</div>
      </div>

      <div class="reveal" id="reveal">
        <div><b>Die Schuppe antwortet.</b></div>
        <div id="revealText" style="margin-top:6px;"></div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== DM-EINSTELLUNGEN =====
  const N = 27; // 3x3x3-Gitter
  const LETTER_ORDER = ["K","R","I","S","T","A","L","L"]; // Lösung in Reihenfolge

  // feste Indizes der Lösungsbuchstaben
  const letterIndices = {
    K:  2,
    R:  5,
    I:  8,
    S: 10,
    T: 12,
    A: 14,
    L1: 18,
    L2: 22
  };

  const REVEAL_TEXT = `
    <b>Aus Chaos wird Ordnung. Aus Stein wird Kristall. Des Steins Perfektion.</b><br><br>
    In diesem Moment richten sich alle Splitter wie von selbst aus, ein dreidimensionales Kristallgitter entsteht.
    Für einen Herzschlag wird der Stein unter deiner Hand heiß – dann öffnet sich in der Mitte des Schildes eine schmale Öffnung,
    aus der sanftes, reines Licht strömt.
  `;

  const EXTRA_DECOYS_PER_STEP = 3; // wie viele falsche Punkte pro richtigem Klick mitgezogen werden
  const RESET_ON_WRONG = true;

  // ===== CANVAS / DOM =====
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");
  const statusEl = document.getElementById("status");
  const revealEl = document.getElementById("reveal");
  const revealTextEl = document.getElementById("revealText");
  const progEl = document.getElementById("prog");
  const maxEl = document.getElementById("max");
  const easyEl = document.getElementById("easy");
  const soundEl = document.getElementById("sound");
  const resetBtn = document.getElementById("reset");
  const progMaxWrap = document.getElementById("progMax");

  function fitCanvas() {
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", () => { fitCanvas(); rebuildLayout(); });
  fitCanvas();

  // ===== RNG =====
  function mulberry32(seed) {
    let a = seed >>> 0;
    return function() {
      a |= 0;
      a = (a + 0x6D2B79F5) | 0;
      let t = Math.imul(a ^ (a >>> 15), 1 | a);
      t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) | 0;
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }
  const rand = mulberry32(123456);

  // ===== LABELS & FARBEN =====
  const labelMap = new Map();
  // echte Lösungspunkte
  labelMap.set(letterIndices.K,  "K");
  labelMap.set(letterIndices.R,  "R");
  labelMap.set(letterIndices.I,  "I");
  labelMap.set(letterIndices.S,  "S");
  labelMap.set(letterIndices.T,  "T");
  labelMap.set(letterIndices.A,  "A");
  labelMap.set(letterIndices.L1, "L");
  labelMap.set(letterIndices.L2, "L");

  // falsche Buchstaben: NICHT K,R,I,S,T,A,L
  const forbidden = new Set(["K","R","I","S","T","A","L"]);
  const alphabet = "BCDEFGHJMNPQUVWXYZ"; // absichtlich ohne K,R,I,S,T,A,L
  let alphaIdx = 0;
  for (let i = 0; i < N; i++) {
    if (labelMap.has(i)) continue; // Lösungspunkte auslassen
    const letter = alphabet[alphaIdx % alphabet.length];
    alphaIdx++;
    labelMap.set(i, letter);
  }

  function rimColorForLabel(label) {
    if (["K","R","I","S","T","A","L"].includes(label)) {
      return "rgba(207,224,255,1)";
    }
    return "rgba(255,220,150,.9)";
  }

  const colorPalette = {
    blue:  { inner: "#f8f9ff", mid: "#a5baff" },
    green: { inner: "#f3fff9", mid: "#7dffd0" },
    amber: { inner: "#fff7dd", mid: "#ffd27c" }
  };
  function colorForPoint(i) {
    const order = ["blue","green","amber"];
    return colorPalette[order[i % order.length]];
  }

  // ===== GITTER / PUNKTE =====
  let points = [];
  let chaos = [];
  let targets = [];
  let coords = [];
  let neighborEdges = [];
  let solvedMask = new Array(N).fill(false);
  let moveMask = new Array(N).fill(false);
  let centerIndex = 0;
  let progress = 0;
  let correctSequence = [];

  function rebuildLayout() {
    const rect = canvas.getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;
    const cx = w * 0.5;
    const cy = h * 0.52;
    const spacing = Math.min(w, h) * 0.12;

    // 3x3x3-Würfel-Koordinaten
    coords = [];
    for (let z = -1; z <= 1; z++) {
      for (let y = -1; y <= 1; y++) {
        for (let x = -1; x <= 1; x++) {
          coords.push({ x, y, z });
        }
      }
    }
    coords.sort((a,b) => (a.z - b.z) || (a.y - b.y) || (a.x - b.x));

    targets = [];
    for (const c of coords) {
      const X = cx + (c.x - c.z) * spacing;
      const Y = cy + (c.y + c.z * 0.6) * spacing;
      targets.push({ x: X, y: Y });
    }

    // Nachbarn im Gitter (für Linien am Ende)
    neighborEdges = [];
    for (let i = 0; i < N; i++) {
      for (let j = i + 1; j < N; j++) {
        const a = coords[i];
        const b = coords[j];
        const dx = Math.abs(a.x - b.x);
        const dy = Math.abs(a.y - b.y);
        const dz = Math.abs(a.z - b.z);
        if (dx + dy + dz === 1) {
          neighborEdges.push({ i, j });
        }
      }
    }

    // Mittelpunkt
    let best = 0;
    let bestD = Infinity;
    for (let i = 0; i < N; i++) {
      const dx = targets[i].x - cx;
      const dy = targets[i].y - cy;
      const d = dx*dx + dy*dy;
      if (d < bestD) { bestD = d; best = i; }
    }
    centerIndex = best;

    // Chaos-Startpositionen
    chaos = [];
    for (let i = 0; i < N; i++) {
      const angle = rand() * Math.PI * 2;
      const radius = (0.18 + rand() * 0.5) * Math.min(w, h);
      const jitterX = (rand() - 0.5) * spacing * 1.3;
      const jitterY = (rand() - 0.5) * spacing * 1.3;
      const cluster = (i % 9 === 0) ? 0.65 : 1.0;
      chaos.push({
        x: cx + Math.cos(angle) * radius * cluster + jitterX,
        y: cy + Math.sin(angle) * radius * cluster + jitterY
      });
    }

    if (points.length !== N) {
      points = chaos.map(p => ({ x:p.x, y:p.y, vx:0, vy:0, flash:0, good:0, bad:0 }));
    }
  }

  rebuildLayout();

  // ===== AUDIO =====
  let audioCtx = null;
  function ensureAudio() {
    if (!soundEl.checked) return null;
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioCtx.state === "suspended") audioCtx.resume();
    return audioCtx;
  }

  function ping(freq, dur = 0.12, type = "sine", gain = 0.06) {
    const ac = ensureAudio();
    if (!ac) return;
    const osc = ac.createOscillator();
    const g = ac.createGain();
    osc.type = type;
    osc.frequency.value = freq;
    g.gain.value = 0.0001;
    osc.connect(g);
    g.connect(ac.destination);
    const t = ac.currentTime;
    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(gain, t + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
    osc.start(t);
    osc.stop(t + dur + 0.02);
  }

  const scale = [0, 3, 5, 7, 10, 12];
  function baseForLabel(label) {
    if (["A","I"].includes(label)) return 220;
    if (["K","R","S","T","L"].includes(label)) return 246;
    return 196;
  }
  function toneForPoint(i) {
    const label = labelMap.get(i) || "";
    const base = baseForLabel(label);
    const step = scale[(i * 2 + 1) % scale.length];
    return base * Math.pow(2, step / 12);
  }
  function goodTone(i) { ping(toneForPoint(i), 0.14, "triangle", 0.085); }
  function badTone() { ping(92, 0.09, "square", 0.05); }

  // ===== STATE / UI =====
  maxEl.textContent = String(LETTER_ORDER.length);

  function setProgress(p) {
    progress = p;
    progEl.textContent = String(p);
    progMaxWrap.style.display = easyEl.checked ? "" : "none";
    revealEl.style.display = "none";
  }

  easyEl.addEventListener("change", () => {
    progMaxWrap.style.display = easyEl.checked ? "" : "none";
  });

  function resetAll() {
    setProgress(0);
    solvedMask.fill(false);
    moveMask.fill(false);
    correctSequence = [];
    for (let i = 0; i < N; i++) {
      points[i].x = chaos[i].x;
      points[i].y = chaos[i].y;
      points[i].vx = 0;
      points[i].vy = 0;
      points[i].flash = 0;
      points[i].good = 0;
      points[i].bad = 0;
    }
    statusEl.textContent =
      "Leuchtende Punkte in wechselnden Farben erscheinen auf der Steinplatte, feine Symbole glimmen im Fels. " +
      "Ein kaum spürbares Vibrieren geht von dem Stein aus, während er langsam wärmer wird.";
  }

  resetBtn.addEventListener("click", resetAll);

  // ===== HITTEST / PICK =====
  function toLocal(evt) {
    const r = canvas.getBoundingClientRect();
    return { x: evt.clientX - r.left, y: evt.clientY - r.top };
  }

  function nearestPoint(x, y) {
    let best = -1;
    let bestD = Infinity;
    for (let i = 0; i < N; i++) {
      const dx = points[i].x - x;
      const dy = points[i].y - y;
      const d = dx*dx + dy*dy;
      if (d < bestD) { bestD = d; best = i; }
    }
    return { i: best, d2: bestD };
  }

  function baseRadius() {
    const rect = canvas.getBoundingClientRect();
    return Math.min(rect.width, rect.height) * 0.022;
  }

  function pointRadius(i) {
    const r = baseRadius();
    return i === centerIndex ? r * 1.2 : r;
  }

  function activateExtraDecoys(count) {
    const candidates = [];
    for (let i = 0; i < N; i++) {
      const label = labelMap.get(i);
      const isSolutionLetter = ["K","R","I","S","T","A","L"].includes(label);
      if (isSolutionLetter) continue;
      if (moveMask[i]) continue;
      candidates.push(i);
    }
    for (let n = 0; n < count && candidates.length > 0; n++) {
      const k = Math.floor(Math.random() * candidates.length);
      const idx = candidates.splice(k, 1)[0];
      moveMask[idx] = true;
      points[idx].good = 0.6;
    }
  }

  function onPick(i) {
    ensureAudio();
    const p = points[i];
    p.flash = 1;
    p.bad = 0;

    const label = labelMap.get(i);
    const needed = LETTER_ORDER[progress];
    const isSolutionLetter = ["K","R","I","S","T","A","L"].includes(label);
    const alreadySolved = solvedMask[i];

    if (isSolutionLetter && label === needed && !alreadySolved) {
      // RICHTIG
      solvedMask[i] = true;
      moveMask[i] = true;
      p.good = 1;
      goodTone(i);
      correctSequence.push(i);

      const t = targets[i];
      if (t) {
        p.vx += (t.x - p.x) * 0.09;
        p.vy += (t.y - p.y) * 0.09;
      }

      activateExtraDecoys(EXTRA_DECOYS_PER_STEP);
      setProgress(progress + 1);

      statusEl.textContent =
        "Die Steinplatte wird spürbar wärmer, und das Vibrieren verstärkt sich – als hättest du einen Resonanzpunkt getroffen.";

      if (progress >= LETTER_ORDER.length) {
        statusEl.textContent =
          "Die Steinplatte pulsiert ein letztes Mal vor Wärme, als die Resonanz sich vollendet.";
        revealTextEl.innerHTML = REVEAL_TEXT;
        revealEl.style.display = "block";
        [246, 310, 369].forEach((f, k) => ping(f, 0.25, "triangle", 0.07 - k * 0.01));
        for (let j = 0; j < N; j++) {
          moveMask[j] = true;
        }
      }
    } else {
      // FALSCH
      p.bad = 1;
      badTone();
      statusEl.textContent =
        "Die Platte verliert etwas an Wärme, und das Vibrieren flacht kurz ab – dies war nicht der richtige Klang.";

      if (RESET_ON_WRONG) {
        setTimeout(() => {
          setProgress(0);
          solvedMask.fill(false);
          moveMask.fill(false);
          correctSequence = [];
          statusEl.textContent =
            "Leuchtende Punkte flackern erneut auf, doch der Stein wirkt zurückhaltender. Er verlangt Geduld.";
          for (let j = 0; j < N; j++) {
            points[j].vx += (chaos[j].x - points[j].x) * 0.06;
            points[j].vy += (chaos[j].y - points[j].y) * 0.06;
          }
        }, 200);
      }
    }
  }

  canvas.addEventListener("pointerdown", (e) => {
    const { x, y } = toLocal(e);
    const hit = nearestPoint(x, y);
    const r = pointRadius(hit.i);
    if (hit.i >= 0 && hit.d2 <= (r * 2.1) * (r * 2.1)) {
      onPick(hit.i);
    }
  });

  // ===== ZEICHNEN =====
  function drawRedLetterPath() {
    if (correctSequence.length < 2) return;
    ctx.save();
    ctx.lineWidth = 2.4;
    ctx.strokeStyle = "rgba(255,80,100,0.95)";
    ctx.beginPath();
    const first = correctSequence[0];
    ctx.moveTo(points[first].x, points[first].y);
    for (let k = 1; k < correctSequence.length; k++) {
      const idx = correctSequence[k];
      ctx.lineTo(points[idx].x, points[idx].y);
    }
    ctx.stroke();
    ctx.restore();
  }

  function drawCubeEdges() {
    if (progress < LETTER_ORDER.length) return;
    ctx.save();
    ctx.lineWidth = 1.3;
    ctx.strokeStyle = "rgba(210,230,255,0.7)";
    for (const e of neighborEdges) {
      const a = points[e.i];
      const b = points[e.j];
      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();
    }
    ctx.restore();
  }

  function drawPoint(i) {
    const p = points[i];
    const r = pointRadius(i);
    const label = labelMap.get(i) || "";
    const rim = rimColorForLabel(label);
    const col = colorForPoint(i);
    const solved = solvedMask[i];

    // Glow
    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.shadowBlur = 24;
    ctx.shadowColor = "rgba(210,225,255,.9)";
    ctx.fillStyle = "rgba(210,225,255,.15)";
    ctx.beginPath();
    ctx.arc(p.x, p.y, r * 2.1, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();

    // Kristallkörper
    const body = ctx.createRadialGradient(
      p.x - r * 0.4, p.y - r * 0.6, r * 0.15,
      p.x,           p.y,           r * 1.7
    );
    body.addColorStop(0, col.inner);
    body.addColorStop(0.55, col.mid);
    body.addColorStop(1, "rgba(10,12,20,0.9)");

    ctx.save();
    ctx.globalAlpha = 0.97;
    ctx.fillStyle = body;
    ctx.strokeStyle = rim;
    ctx.lineWidth = solved ? 2.0 : 1.4;

    ctx.beginPath();
    const steps = 10;
    for (let k = 0; k <= steps; k++) {
      const a = (k / steps) * Math.PI * 2;
      const jitter = 0.9 + Math.sin((i + 1) * 8.7 + k * 1.5) * 0.06;
      const rr = r * jitter;
      const x = p.x + Math.cos(a) * rr;
      const y = p.y + Math.sin(a) * rr;
      if (k === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    // innerer Glanz
    ctx.globalAlpha = 0.35 + (solved ? 0.3 : 0.15) + p.good * 0.25;
    ctx.fillStyle = "rgba(255,255,255,.26)";
    ctx.beginPath();
    ctx.arc(p.x - r * 0.25, p.y - r * 0.25, r * 0.6, 0, Math.PI * 2);
    ctx.fill();

    // roter Fehl-Blink
    if (p.bad > 0.01) {
      ctx.globalAlpha = p.bad * 0.9;
      ctx.strokeStyle = "rgba(255,60,90,1)";
      ctx.lineWidth = 2.4;
      ctx.beginPath();
      ctx.arc(p.x, p.y, r * 2.3, 0, Math.PI * 2);
      ctx.stroke();
    }

    // Klick-Flash (hell)
    if (p.flash > 0.01 && p.bad < 0.01) {
      ctx.globalAlpha = p.flash * 0.8;
      ctx.strokeStyle = "rgba(255,255,255,0.95)";
      ctx.lineWidth = 2.4;
      ctx.beginPath();
      ctx.arc(p.x, p.y, r * 2.4, 0, Math.PI * 2);
      ctx.stroke();
    }

    // Buchstaben (alle Punkte haben einen Buchstaben)
    ctx.globalAlpha = 1;
    ctx.font = `700 ${Math.max(15, r * 1.5)}px system-ui,-apple-system,Segoe UI,Roboto,Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(255,255,255,0.9)";
    ctx.fillStyle = "rgba(0,0,0,0.98)";
    ctx.strokeText(label, p.x, p.y + 0.5);
    ctx.fillText(label, p.x, p.y + 0.5);

    // Zentrumsschuppe nach Lösung
    if (progress >= LETTER_ORDER.length && i === centerIndex) {
      ctx.globalAlpha = 0.97;
      ctx.strokeStyle = "rgba(166,255,203,1)";
      ctx.fillStyle = "rgba(166,255,203,.16)";
      ctx.lineWidth = 1.7;
      const sr = r * 1.6;
      ctx.beginPath();
      ctx.moveTo(p.x, p.y - sr);
      ctx.quadraticCurveTo(p.x + sr * 0.9, p.y - sr * 0.2, p.x + sr * 0.55, p.y + sr * 0.95);
      ctx.quadraticCurveTo(p.x, p.y + sr * 1.25, p.x - sr * 0.55, p.y + sr * 0.95);
      ctx.quadraticCurveTo(p.x - sr * 0.9, p.y - sr * 0.2, p.x, p.y - sr);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }

    ctx.restore();
  }

  function step() {
    const rect = canvas.getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;
    const minD = baseRadius() * 2.1;

    // Bewegung
    for (let i = 0; i < N; i++) {
      const p = points[i];
      const t = targets[i];
      if (moveMask[i] && t) {
        const dx = t.x - p.x;
        const dy = t.y - p.y;
        p.vx += dx * 0.035;
        p.vy += dy * 0.035;
      } else {
        p.vx += (Math.random() - 0.5) * 0.015;
        p.vy += (Math.random() - 0.5) * 0.015;
      }
      p.vx *= 0.88;
      p.vy *= 0.88;
      p.x += p.vx;
      p.y += p.vy;

      const pad = 26;
      if (p.x < pad) { p.x = pad; p.vx *= -0.4; }
      if (p.x > w - pad) { p.x = w - pad; p.vx *= -0.4; }
      if (p.y < pad) { p.y = pad; p.vy *= -0.4; }
      if (p.y > h - pad) { p.y = h - pad; p.vy *= -0.4; }

      p.flash *= 0.8;
      p.good  *= 0.9;
      p.bad   *= 0.4;
    }

    // einfache Repulsion gegen Überlappung
    for (let i = 0; i < N; i++) {
      for (let j = i + 1; j < N; j++) {
        const a = points[i];
        const b = points[j];
        let dx = b.x - a.x;
        let dy = b.y - a.y;
        const dist = Math.hypot(dx, dy);
        if (dist > 0 && dist < minD) {
          const overlap = (minD - dist) * 0.5;
          const nx = dx / dist;
          const ny = dy / dist;
          a.x -= nx * overlap;
          a.y -= ny * overlap;
          b.x += nx * overlap;
          b.y += ny * overlap;
        }
      }
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawCubeEdges();
    drawRedLetterPath();
    for (let i = 0; i < N; i++) drawPoint(i);

    requestAnimationFrame(step);
  }

  // Init
  setProgress(0);
  resetAll();
  step();
})();
</script>
</body>
</html>
